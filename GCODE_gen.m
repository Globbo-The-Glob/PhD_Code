% PEANO HASEL GCDOE GEN
% Enter signature and other variables 
% get actuator gcode

%% Signature

lp = 20; %mm pouch length
w = 120; % mm width
f = 0.6; % electrodle percentage coverage
g = 6; % mm gap width at +-0.5w
s = 20; % mm injection port lenght, g is width
taper = 2; 
n = 1; % number of series acutators

filename = append(num2str(w),'_',num2str(lp),'_',num2str(n),'.gcode');
%%
% __| |__
% |      |   top
%
%%
% ---  ---
% |      |  mids
%
%%
% ---  ---
% |      |   bottom
% --------

% +(1-f)*lp needed for bucklers

%% Inital file creation and header
% take from working files 
gcode = fopen(filename,'w');
fprintf(gcode,datestr(datetime('now')));
fprintf(gcode,'\n');
fprintf(gcode,';Generated by yah boy, big up standardisation of file formats\n');
fprintf(gcode,'G21; mm\n');
fprintf(gcode,'G0 Z8; z to safe\n');
fprintf(gcode,'G0 X0 Y0\n'); % slap that boy to the origin




%% Main loop

% GLOBAL ORIGIN BOTTOM LEFT
% local origins shift to bottom right of each new cell, top right of old
% ACW movement
% G0 is standard move
% G1 is cut but not really relevant for this. 

% First is bottom which is closed box with gap at top
i = 0;
while i <= n
    i = i + 1;
    if i == n && i == 1 % case for single actuator 
        % draw points for closed bottom and injection port
        c = [w 0; w lp; 0.5*(w+g) lp; 0.5*(w+g)+taper lp+s;0.5*(w-g)-taper lp+s; 0.5*(w-g) lp; 0 lp; 0 0];
        fprintf(gcode,'single\n\n');
        fprintf(gcode,'G0 Z-0.2 X0 Y0\n');
        fprintf(gcode,'G1 Z-0.2 X0 Y0\n');
        fprintf(gcode,'G1 F400 X%.7g Y%.7g\n',c(1,:)); % draw bottom line
%         gcode = buckler(gcode,f,lp,c(1,:),1); % make a right buckler
        for j = drange(1,4)
            fprintf(gcode,'G1 F400 X%.7g Y%.7g\n',c(j,:));
        end
        fprintf(gcode,'G0 Z8\n'); % up
        fprintf(gcode,'G0 X%.7g Y%.7g\n', c(5,:)); %over gap
        fprintf(gcode,'G0 Z-0.2\n'); %back down
        for j = drange(6,8)
            fprintf(gcode,'G1 F400 X%.7g Y%.7g\n',c(j,:));
        end
        fprintf(gcode,'G0 Z8\n'); % up
        break
        % Finished

    elseif i ~= n && i==1% case for bottom
        % draw close bottom box with gap
        c = [w 0; w lp; 0.5*(w+g) lp; 0.5*(w-g) lp; 0 lp; 0 0];
        fprintf(gcode,'bottom\n\n');
        fprintf(gcode,'G0 Z-0.2 X0 Y0\n');
        fprintf(gcode,'G1 Z-0.2 X0 Y0\n');
        fprintf(gcode,'G1 F400 X%.7g Y%.7g\n',c(1,:));
%         gcode = buckler(gcode,f,lp,c(1,:),1); % make a right buckler
        for j = drange(1,3)
            fprintf(gcode,'G1 F400 X%.7g Y%.7g\n',c(j,:));
        end
        fprintf(gcode,'G0 Z8\n'); % up
        fprintf(gcode,'G0 X%.7g Y%.7g\n', c(4,:)); %over gap
        fprintf(gcode,'G0 Z-0.2\n'); %back down
        for j = drange(5,6)
            fprintf(gcode,'G1 F400 X%.7g Y%.7g\n',c(j,:));
        end
%         gcode = buckler(gcode,f,lp,c(6,:),0); % make a left buckler
        fprintf(gcode,'G0 Z8\n'); % up
        fprintf(gcode,'G0 F400 X%.7g Y%.7g\n',c(2,:)); %new origin

    elseif  i == n && i ~= 1 % case for top of series
        % draw tops w/ injection port
        c = [w 0; w lp; 0.5*(w+g) lp; 0.5*(w+g)+taper lp+s;0.5*(w-g)-taper lp+s; 0.5*(w-g) lp; 0 lp; 0 00];
        offset = zeros(size(c),'like',c);
        offset(:,2) = offset(:,2) + (n-1)*lp; % bump all y values
        c = c + offset;
        fprintf(gcode,'top\n\n');
        fprintf(gcode,'G0 Z-0.2\n');
%         gcode = buckler(gcode,f,lp,c(1,:),1); % make a ight buckler
        for j = drange(1,4)
            fprintf(gcode,'G1 F400 X%.7g Y%.7g\n',c(j,:));
        end
        fprintf(gcode,'G0 Z8\n'); % up
        fprintf(gcode,'G0 X%.7g Y%.7g\n', c(5,:)); %over gap
        fprintf(gcode,'G0 Z-0.2\n'); %back down
        for j = drange(6,8)
            fprintf(gcode,'G1 F400 X%.7g Y%.7g\n',c(j,:));
        end
%         gcode = buckler(gcode,f,lp,c(8,:),0); % make a left buckler
        fprintf(gcode,'G0 Z8; z to safe\n');
        break

    else % mids
        % draw top "L's" w/ gap
        % currently at [w,(i-1)*lp] from last run
        c = [w 0; w lp; 0.5*(w+g) lp; 0.5*(w-g) lp; 0 lp; 0 0];
        offset = zeros(size(c),'like',c);
        offset(:,2) = offset(:,2) + (i-1)*lp; % bump all y values
        fprintf(gcode,'mid\n\n');
        c = c + offset;
        % draw case 3 []
        fprintf(gcode,'G0 Z-0.2\n'); % down yah go
%         gcode = buckler(gcode,f,lp,c(1,:),1); % make a right buckler
        for j = drange(1,3)
            fprintf(gcode,'G1 F400 X%.7g Y%.7g\n',c(j,:));
        end
        fprintf(gcode,'G0 Z8\n'); % up
        fprintf(gcode,'G0 X%.7g Y%.7g\n', c(4,:)); %over gap
        fprintf(gcode,'G0 Z-0.2\n'); %back down
        for j = drange(5,6)
            fprintf(gcode,'G1 F400 X%.7g Y%.7g\n',c(j,:));
        end
%         gcode = buckler(gcode,f,lp,c(6,:),0); % make a left buckler
        fprintf(gcode,'G0 Z8\n');
        fprintf(gcode,'G0 F400 X%.7g Y%.7g\n',c(2,:)); %new origin in top right
    end
end
fprintf(gcode,'G0 Z8; z to safe\n');
fprintf(gcode,'G0 X0 Y0\n'); % slap that boy to the origin
fclose(gcode);

function gcode = buckler(gcode, f, lp, start, right)
    % all are ccw
    r =  ((1-f)*lp)/4;
    ppi = [0 r]; % incriment
    if right == 1 % case for right side buckler
        centre1 = [0 r]; % relative arc centre 
        stop1  = start + 2*ppi;
        centre2 = [0 r];
        stop2 = start + 4*ppi;
    else % left buckler
        centre1 = [0 -r]; % relative arc centre 
        stop1  = start - 2*ppi;
        centre2 = [0 -r];
        stop2 = start - 4*ppi;
    end
    fprintf(gcode,'G3 F400 X%.7g Y%.7g ', stop1 );
    fprintf(gcode,'I%.7g J%.7g\n', centre1);
    fprintf(gcode,'G3 F400 X%.7g Y%.7g ', stop2);
    fprintf(gcode,'I%.7g J%.7g\n',centre2);
end